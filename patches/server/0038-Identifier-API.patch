From 5c706f025de0a303f3f2b9fbc1a88d9ab65610dd Mon Sep 17 00:00:00 2001
From: willies952002 <admin@domnian.com>
Date: Mon, 25 Dec 2017 22:08:32 -0500
Subject: [PATCH] Identifier API

Seems silly, but I want to have a common interface to represent an identity
but not have risk of 2 objects equalling each other.

Example: ChunkIdentifier and a ResidenceIdentifier are 2 ways to identify a context
but cant ever equal each other.

Implementers should not expose entropy data, just provide equal/hashcode.

Objects represented by an Identifier, should be able to use them as their equal/hashcodes.

Manually Applied Patch from Empire Minecraft - Originally by Aikar
---
 .../org/bukkit/craftbukkit/CraftChunk.java    | 36 +++++++++++++++++++
 .../bukkit/craftbukkit/block/CraftBlock.java  | 29 +++++++++++++++
 2 files changed, 65 insertions(+)

diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 0a47353b4..ff42a2e15 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -29,6 +29,7 @@ public class CraftChunk implements Chunk {
         worldServer = (WorldServer) getHandle().world;
         x = getHandle().locX;
         z = getHandle().locZ;
+        chunkKey = new ChunkIdentifier(this); // PaperDragon
     }
 
     public World getWorld() {
@@ -278,4 +279,39 @@ public class CraftChunk implements Chunk {
     static {
         Arrays.fill(emptySkyLight, (byte) 0xFF);
     }
+
+    // PaperDragon start
+    private final ChunkIdentifier chunkKey;
+    public com.domnian.paperdragon.Identifier getIdentifier() {
+        return chunkKey;
+    }
+
+    @Override
+    public int hashCode() {
+        return chunkKey.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return obj instanceof Chunk && chunkKey.equals(((Chunk) obj).getIdentifier());
+    }
+
+    private static class ChunkIdentifier implements com.domnian.paperdragon.Identifier {
+        private final World world;
+        private final int x, z;
+        private ChunkIdentifier(final Chunk chunk) {
+            this.world = chunk.getWorld();
+            this.x = chunk.getX();
+            this.z = chunk.getZ();
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            final ChunkIdentifier that = (ChunkIdentifier) o;
+            return x == that.x && z == that.z && world.equals(that.world);
+        }
+    }
+    // PaperDragon end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 468a36ad5..0d87afede 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -35,6 +35,7 @@ public class CraftBlock implements Block {
     public CraftBlock(GeneratorAccess world, BlockPosition position) {
         this.world = world;
         this.position = position;
+        this.blockKey = new BlockIdentifier(); // PaperDragon
     }
 
     public static CraftBlock at(GeneratorAccess world, BlockPosition position) {
@@ -605,4 +606,32 @@ public class CraftBlock implements Block {
     public void removeMetadata(String metadataKey, Plugin owningPlugin) {
         getCraftWorld().getBlockMetadata().removeMetadata(this, metadataKey, owningPlugin);
     }
+
+    // PaperDragon start
+    private final com.domnian.paperdragon.Identifier blockKey;
+    @Override
+    public com.domnian.paperdragon.Identifier getIdentifier() {
+        return blockKey;
+    }
+
+    private class BlockIdentifier implements com.domnian.paperdragon.Identifier {
+        private final CraftBlock block;
+        private BlockIdentifier() {
+            this.block = CraftBlock.this;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            BlockIdentifier that = (BlockIdentifier) o;
+            return block.getX() == that.block.getX() && block.getY() == that.block.getY() && block.getZ() == that.block.getZ() && block.getWorld().equals(that.block.getWorld());
+        }
+
+        @Override
+        public int hashCode() {
+            return 73 * (73 * (73 * block.getChunk().getWorld().hashCode() + block.getX()) + block.getY()) + block.getZ();
+        }
+    }
+    // PaperDragon end
 }
-- 
2.18.0

