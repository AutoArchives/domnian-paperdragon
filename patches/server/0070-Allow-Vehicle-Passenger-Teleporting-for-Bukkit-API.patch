From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 10 Apr 2016 22:50:33 -0400
Subject: [PATCH] Allow Vehicle/Passenger Teleporting for Bukkit API

If Bukkit teleport is called, teleport the whole set of entities together and maintain the chain.

diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 428371e196e32bb09614b87d3fc9b438f683da71..33832962ed05f193441d35a09dde6e60ec05a4ce 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -833,7 +833,7 @@ public abstract class PlayerList {
 
     public ServerPlayer respawn(ServerPlayer entityplayer, ServerLevel worldserver, boolean flag, Location location, boolean avoidSuffocation, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag...respawnFlags) {
         // Paper end
-        entityplayer.stopRiding(); // CraftBukkit
+        //entityplayer.stopRiding(); // CraftBukkit // PaperDragon - remove stop riding
         this.players.remove(entityplayer);
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         entityplayer.getLevel().removePlayerImmediately(entityplayer, Entity.RemovalReason.DISCARDED);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index dde9b521fa0aed2644a4dc8f952974955234c4dc..4b04c87285bd68e9f6e437a257a916808635fa8e 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -230,7 +230,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, i
     public ImmutableList<Entity> passengers;
     protected int boardingCooldown;
     @Nullable
-    private Entity vehicle;
+    public Entity vehicle; // PaperDragon - make public
     public Level level;
     public double xo;
     public double yo;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index d7d935c3abf6c5ceb4feffaf9cdf0f668d1f3b86..7e9c92d07bc678953dd7e71aafd9871dd7dd432e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -5,6 +5,7 @@ import com.domnian.paperdragon.api.meta.TempMetaMap; // PaperDragon
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableList; // PaperDragon
 import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
@@ -569,23 +570,104 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.teleport(location, TeleportCause.PLUGIN);
     }
 
+    // PaperDragon start - vehicle passenger teleporting
+    private static CraftEntity teleportingEntity;
+    private CraftEntity storedRoot;
+    private ImmutableList<CraftEntity> storedPassengers;
+    void detachEntities() {
+        if (teleportingEntity == null) {
+            teleportingEntity = this;
+            this.storedRoot = entity.getRootVehicle().getBukkitEntity();
+            this.storedRoot.detachEntities();
+            teleportingEntity = null;
+            return;
+        }
+        this.storedPassengers = this.entity.passengers.stream().map(Entity::getBukkitEntity).collect(ImmutableList.toImmutableList());
+        this.forceEjectPassengers();
+        for (CraftEntity ent : this.storedPassengers) {
+            ent.detachEntities();
+        }
+    }
+    void forceEjectPassengers() {
+        for (int i = this.entity.passengers.size() - 1; i >= 0; --i) {
+            Entity passenger = (this.entity.passengers.get(i));
+            passenger.vehicle = null;
+        }
+        this.entity.passengers = ImmutableList.of();
+    }
+    void teleportAndReattachEntities(Location location) {
+        if (teleportingEntity == null) {
+            if (this.storedRoot != null) {
+                teleportingEntity = this;
+                this.storedRoot.teleportAndReattachEntities(location);
+                this.storedRoot.reattachPassengers();
+                this.storedRoot = null;
+                teleportingEntity = null;
+            }
+            return;
+        }
+        if (!teleportingEntity.equals(this)) {
+            this.teleportEntity(location);
+        }
+        for (CraftEntity ent : this.storedPassengers) {
+            ent.teleportAndReattachEntities(location);
+        }
+    }
+    void teleportEntity(Location location) {
+        if (getWorld().equals(location.getWorld())) {
+            if (this.storedPassengers == null || this.storedPassengers.isEmpty()) {
+                this.entity.moveTo(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+                this.entity.setYHeadRot(location.getYaw());
+            } else {
+                // This section has code from TeleportCommand class
+                ServerLevel world = (ServerLevel) this.entity.level;
+                Entity entity1 = this.entity;
+                Entity target = entity1.getType().create(world);
+                if (target == null) {
+                    return;
+                }
+                target.restoreFrom(entity1);
+                target.moveTo(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+                target.setYHeadRot(location.getYaw());
+                entity1.setRemoved(Entity.RemovalReason.CHANGED_DIMENSION);
+                this.setHandle(target);
+                world.addDuringTeleport(target);
+            }
+        } else {
+            this.entity.teleportTo(((CraftWorld) location.getWorld()).getHandle(), new BlockPos(location.getX(), location.getY(), location.getZ()));
+        }
+    }
+    private void reattachPassengers() {
+        if (this.storedPassengers == null) {
+            return;
+        }
+        this.entity.passengers = this.storedPassengers.stream().map(CraftEntity::getHandle).collect(ImmutableList.toImmutableList());
+        for (CraftEntity passenger : this.storedPassengers) {
+            passenger.getHandle().vehicle = this.getHandle();
+            passenger.reattachPassengers();
+        }
+        this.storedPassengers = null;
+    }
+    // PaperDragon end - vehicle passenger teleporting
     @Override
     public boolean teleport(Location location, TeleportCause cause) {
         Preconditions.checkArgument(location != null, "location");
         location.checkFinite();
 
-        if (this.entity.isVehicle() || this.entity.isRemoved()) {
+        if (this.entity.isRemoved()) { // PaperDragon
             return false;
         }
 
         // If this entity is riding another entity, we must dismount before teleporting.
-        this.entity.stopRiding();
+        //this.entity.stopRiding(); // PaperDragon
+        this.detachEntities(); // PaperDragon
 
         // Let the server handle cross world teleports
         if (!location.getWorld().equals(this.getWorld())) {
             // Prevent teleportation to an other world during world generation
             Preconditions.checkState(!entity.generation, "Cannot teleport entity to an other world during world generation");
             this.entity.teleportTo(((CraftWorld) location.getWorld()).getHandle(), new BlockPos(location.getX(), location.getY(), location.getZ()));
+            this.teleportAndReattachEntities(location); // PaperDragon
             return true;
         }
 
@@ -594,6 +676,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         // SPIGOT-619: Force sync head rotation also
         this.entity.setYHeadRot(location.getYaw());
 
+        this.teleportAndReattachEntities(location); // PaperDragon
         return true;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 5415d4e4c15d3f04134a3a4651cb417bd614ecfe..bff99133109c2666d05c4ab1bb13467412072c9d 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1029,7 +1029,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
 
         // If this player is riding another entity, we must dismount before teleporting.
-        entity.stopRiding();
+        //entity.stopRiding(); // PaperDragon
 
         // SPIGOT-5509: Wakeup, similar to riding
         if (this.isSleeping()) {
@@ -1049,14 +1049,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             this.getHandle().closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.TELEPORT); // Paper
         }
 
+        this.detachEntities(); // PaperDragon
         // Check if the fromWorld and toWorld are the same.
         if (fromWorld == toWorld) {
             entity.connection.teleport(to);
         } else {
             server.getHandle().respawn(entity, toWorld, true, to, !toWorld.paperConfig.disableTeleportationSuffocationCheck); // Paper
         }
+        this.teleportAndReattachEntities(location); // PaperDragon
         return true;
     }
+    // PaperDragon start
+    @Override
+    void teleportEntity(Location location) {
+        ServerPlayer entity = this.getHandle();
+        if (getWorld().equals(location.getWorld())) {
+            entity.connection.teleport(location);
+        } else {
+            ServerLevel toWorld = ((CraftWorld) location.getWorld()).getHandle();
+            server.getHandle().respawn(entity, toWorld, true, location, !toWorld.paperConfig.disableTeleportationSuffocationCheck);
+        }
+    }
+    // PaperDragon end
 
     // Paper start - Ugly workaround for SPIGOT-1915 & GH-114
     @Override
