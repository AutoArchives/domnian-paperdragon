From bb7351821ba794878b0160e0739759aca0a3e53a Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 4 Mar 2013 23:35:02 -0500
Subject: [PATCH] Persistent and Temporary Meta API

---
 .../paperdragon/api/CraftDragonAPI.java       |   3 +
 .../paperdragon/api/meta/CraftDAPI_Meta.java  |  80 +++
 .../protocol/game/PacketPlayOutMapChunk.java  |   1 +
 .../game/PacketPlayOutTileEntityData.java     |   1 +
 .../net/minecraft/server/MetaApiAccessor.java | 582 ++++++++++++++++++
 .../server/level/PlayerChunkMap.java          |   1 +
 .../minecraft/server/level/WorldServer.java   |   2 +-
 .../net/minecraft/world/entity/Entity.java    |   3 +
 .../java/net/minecraft/world/level/World.java |   3 +-
 .../world/level/block/entity/TileEntity.java  |   3 +
 .../minecraft/world/level/chunk/Chunk.java    |   2 +
 .../world/level/chunk/ProtoChunk.java         |   2 +
 .../level/chunk/ProtoChunkExtension.java      |   1 +
 .../chunk/storage/ChunkRegionLoader.java      |   2 +
 .../world/level/storage/WorldDataServer.java  |   9 +-
 .../org/bukkit/craftbukkit/CraftChunk.java    |   2 +
 .../org/bukkit/craftbukkit/CraftServer.java   |   3 +
 .../block/CraftBlockEntityState.java          |   7 +
 .../craftbukkit/block/CraftBlockState.java    |   7 +
 .../craftbukkit/entity/CraftEntity.java       |   2 +
 .../craftbukkit/event/CraftEventFactory.java  |   5 +
 .../craftbukkit/inventory/CraftInventory.java |  11 +
 22 files changed, 728 insertions(+), 4 deletions(-)
 create mode 100644 src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java
 create mode 100644 src/main/java/net/minecraft/server/MetaApiAccessor.java

diff --git a/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java b/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
index 21bd42ff9d..b11af17efb 100644
--- a/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
+++ b/src/main/java/com/domnian/paperdragon/api/CraftDragonAPI.java
@@ -23,6 +23,8 @@
 
 package com.domnian.paperdragon.api;
 
+import com.domnian.paperdragon.api.meta.CraftDAPI_Meta;
+
 public final class CraftDragonAPI extends DragonAPI {
 
     private CraftDragonAPI() {}
@@ -31,6 +33,7 @@ public final class CraftDragonAPI extends DragonAPI {
     static {
         entity = new CraftDAPI_Entity();
         misc = new CraftDAPI_Misc();
+        meta = new CraftDAPI_Meta();
     }
 
 }
diff --git a/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java b/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java
new file mode 100644
index 0000000000..2afd6f2510
--- /dev/null
+++ b/src/main/java/com/domnian/paperdragon/api/meta/CraftDAPI_Meta.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2016 Starlis LLC / Daniel Ennis (Aikar) - MIT License
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining
+ *  a copy of this software and associated documentation files (the
+ *  "Software"), to deal in the Software without restriction, including
+ *  without limitation the rights to use, copy, modify, merge, publish,
+ *  distribute, sublicense, and/or sell copies of the Software, and to
+ *  permit persons to whom the Software is furnished to do so, subject to
+ *  the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be
+ *  included in all copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package com.domnian.paperdragon.api.meta;
+
+import com.domnian.paperdragon.api.Vector3i;
+import net.minecraft.server.MetaApiAccessor;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.entity.Entity;
+
+import java.util.Map;
+
+public class CraftDAPI_Meta implements DAPI_Meta {
+
+    @Override
+    public PersistentMetaMap getTileEntityMetaMap(BlockState tileEntity, boolean isWrite) {
+        return MetaApiAccessor.getTileEntityMetaMap(tileEntity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getBlockMetaMap(Location loc, boolean isWrite) {
+        return MetaApiAccessor.getBlockMetaMap(loc, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getChunkMetaMap(Chunk chunk, boolean isWrite) {
+        return MetaApiAccessor.getChunkMetaMap(chunk, isWrite);
+    }
+
+    @Override
+    public TempMetaMap getChunkTempMetaMap(Chunk chunk, boolean isWrite) {
+        return chunk.getTempMeta();
+    }
+
+    @Override
+    public Map<Vector3i, PersistentMetaMap> getChunkMetaData(Chunk chunk) {
+        return ((CraftChunk) chunk).getHandle().chunkMeta;
+    }
+
+    @Override
+    public PersistentMetaMap getEntityMetaMap(Entity entity, boolean isWrite) {
+        return MetaApiAccessor.getEntityMetaMap(entity, isWrite);
+    }
+
+    @Override
+    public PersistentMetaMap getWorldMetaMap(World world) {
+        return MetaApiAccessor.getWorldMetaMap((CraftWorld) world);
+    }
+
+    @Override
+    public Map<String, Object> getBlockTempMeta(Block block, boolean isWrite) {
+        return MetaApiAccessor.getChunkTempMeta(block, isWrite);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
index 3047cf8c4e..b92e1e3093 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutMapChunk.java
@@ -106,6 +106,7 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
                 // Paper end
                 NBTTagCompound nbttagcompound = tileentity.b();
                 if (tileentity instanceof TileEntitySkull) { TileEntitySkull.sanitizeTileEntityUUID(nbttagcompound); } // Paper
+                net.minecraft.server.MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // PaperDragon
 
                 this.g.add(nbttagcompound);
             }
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
index ec4c658c8a..0699de3b3a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutTileEntityData.java
@@ -15,6 +15,7 @@ public class PacketPlayOutTileEntityData implements Packet<PacketListenerPlayOut
     public PacketPlayOutTileEntityData() {}
 
     public PacketPlayOutTileEntityData(BlockPosition blockposition, int i, NBTTagCompound nbttagcompound) {
+        net.minecraft.server.MetaApiAccessor.filterTileEntityMeta(nbttagcompound); // PaperDragon
         this.a = blockposition;
         this.b = i;
         this.c = nbttagcompound;
diff --git a/src/main/java/net/minecraft/server/MetaApiAccessor.java b/src/main/java/net/minecraft/server/MetaApiAccessor.java
new file mode 100644
index 0000000000..5db3a47fe7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MetaApiAccessor.java
@@ -0,0 +1,582 @@
+package net.minecraft.server;
+
+import com.mojang.serialization.Dynamic;
+import net.minecraft.core.BlockPosition;
+import net.minecraft.nbt.*;
+import net.minecraft.server.level.PlayerChunk;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.util.datafix.DataConverters;
+import net.minecraft.util.datafix.fixes.DataConverterTypes;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.entity.TileEntity;
+import net.minecraft.world.level.chunk.Chunk;
+import net.minecraft.world.level.chunk.IChunkAccess;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.ProtoChunkExtension;
+import net.minecraft.world.level.storage.WorldDataServer;
+import org.bukkit.Bukkit;
+import com.domnian.paperdragon.api.Vector3i;
+import com.domnian.paperdragon.api.meta.PersistentMetaList;
+import com.domnian.paperdragon.api.meta.PersistentMetaMap;
+import com.domnian.paperdragon.events.BlockWithPersistentMetaClearedEvent;
+import org.bukkit.Location;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+
+import java.util.*;
+import java.util.regex.Pattern;
+
+public final class MetaApiAccessor {
+
+    private static final String META_MAP = "MetaMap";
+    private static final String META_TYPE = "MetaType";
+    private static final String ITEM = "Item";
+    private static final String ENTITY_META = "_EntityMeta";
+    private static final String TILEENTITY_META = "_TileEntityMeta";
+    private static final String WORLD_META = "_WorldMeta";
+    private static final String CHUNK_META_LIST = "_ChunkMetaList";
+    private static final String BLOCK_POS = "_BlockPos";
+    private static final String CHUNK_META = "_ChunkMeta";
+
+    private MetaApiAccessor() {}
+
+    public static PersistentMetaMap getWorldMetaMap(CraftWorld world) {
+        return ((WorldDataServer) world.getHandle().worldData).metaMap;
+    }
+
+    public static PersistentMetaMap getTileEntityMetaMap(org.bukkit.block.BlockState block, boolean isWrite) {
+        final CraftBlockState craftBlock = (CraftBlockState) block;
+        final TileEntity tileEntity = ((CraftWorld) craftBlock.getWorld()).getHandle().getTileEntity(MCUtil.toBlockPosition(craftBlock.getLocation()));
+        if (tileEntity == null) {
+            return null;
+        }
+        if (tileEntity.metaMap == null && isWrite) {
+            tileEntity.metaMap = new PersistentMetaMap();
+        }
+        return tileEntity.metaMap;
+    }
+
+    /**
+     * Util for getting a MetaMap by location
+     * @param loc
+     * @return
+     */
+    public static PersistentMetaMap getBlockMetaMap(org.bukkit.Location loc, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) loc.getChunk()).getHandle(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), isWrite);
+    }
+
+    /**
+     * Util for getting a MetaMap for a chunk
+     * @param chunk
+     * @return
+     */
+    public static PersistentMetaMap getChunkMetaMap(org.bukkit.Chunk chunk, boolean isWrite) {
+        return getBlockMetaMap(((CraftChunk) chunk).getHandle(), 0, -1, 0, isWrite);
+    }
+
+    /**
+     * Gets the metamap for the specified coords, creating it if it doesnt exists
+     * @param handle
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    private static PersistentMetaMap getBlockMetaMap(Chunk handle, int x, int y, int z, boolean isWrite) {
+        ChunkPersistentMeta meta = handle.chunkMeta;
+        if (meta == null) {
+            if (!isWrite) {
+                return null;
+            }
+            meta = handle.chunkMeta = new ChunkPersistentMeta();
+        }
+        Vector3i coords = new Vector3i(x, y, z);
+        if (!isWrite && !meta.containsKey(coords)) {
+            return null;
+        }
+        PersistentMetaMap ret = meta.get(coords);
+        if (ret == null) {
+            if (isWrite) {
+                ret = new PersistentMetaMap();
+                meta.put(coords, ret);
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * Util for getting a MetaMap for an Entity
+     * @param craftentity
+     * @return
+     */
+    public static PersistentMetaMap getEntityMetaMap(org.bukkit.entity.Entity craftentity, boolean isWrite) {
+        Entity entity = ((CraftEntity) craftentity).getHandle();
+        if (entity.metaMap == null) {
+            if (isWrite) {
+                entity.metaMap = new PersistentMetaMap();
+            }
+        }
+        return entity.metaMap;
+    }
+
+    public static void loadEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (nbt.hasKey(ENTITY_META)) {
+            entity.metaMap = getMetaMapFromCompound(nbt.getCompound(ENTITY_META));
+        }
+    }
+
+    public static void saveEntityMeta(Entity entity, NBTTagCompound nbt) {
+        if (entity.metaMap != null && !entity.metaMap.isEmpty()) {
+            nbt.set(ENTITY_META, getNbtFromObject(entity.metaMap));
+        }
+    }
+
+    public static void loadTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (nbt.hasKey(TILEENTITY_META)) {
+            tileEntity.metaMap = getMetaMapFromCompound(nbt.getCompound(TILEENTITY_META));
+        }
+    }
+
+    public static void saveTileEntityMeta(TileEntity tileEntity, NBTTagCompound nbt) {
+        if (tileEntity.metaMap != null && !tileEntity.metaMap.isEmpty()) {
+            nbt.set(TILEENTITY_META, getNbtFromObject(tileEntity.metaMap));
+        }
+    }
+
+    public static void loadWorldMeta(WorldDataServer world, Dynamic<NBTBase> nbt) {
+        NBTTagCompound nbtmeta = (NBTTagCompound) nbt.getElement(WORLD_META, null);
+        if (nbtmeta != null) {
+            world.metaMap = getMetaMapFromCompound(nbtmeta);
+        }
+        if (world.metaMap == null) {
+            world.metaMap = new PersistentMetaMap();
+        }
+    }
+
+    public static void saveWorldMeta(WorldDataServer worldData, NBTTagCompound nbt) {
+        if (worldData.metaMap != null && !worldData.metaMap.isEmpty()) {
+            NBTBase nbtmeta = getNbtFromObject(worldData.metaMap);
+            nbt.set(WORLD_META, nbtmeta);
+        }
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void saveChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            saveChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to save meta for");
+        saveChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Saves this chunks Meta Data into NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (chunk.chunkMeta == null || chunk.chunkMeta.isEmpty()) {
+            return;
+        }
+        NBTTagList meta = new NBTTagList();
+        for (Map.Entry<Vector3i, PersistentMetaMap> entry : chunk.chunkMeta.entrySet()) {
+            PersistentMetaMap list = entry.getValue();
+            if (!list.isEmpty()) {
+                NBTTagCompound pos = serializePos(entry.getKey());
+                NBTTagCompound metacmp = getCompoundFromMetaMap(list);
+                metacmp.set(BLOCK_POS, pos);
+                meta.add(metacmp);
+            }
+        }
+
+        if (!meta.isEmpty()) {
+            cmp.set(CHUNK_META_LIST, meta);
+        }
+    }
+
+    /**
+     * Saves this protoChunk's Meta Data into NBT
+     * @param cmp
+     * @param protoChunk
+     */
+    static void saveChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (protoChunk.chunkMeta != null) {
+            cmp.set(CHUNK_META, protoChunk.chunkMeta);
+        } else if (protoChunk.chunkMetaList != null) {
+            cmp.set(CHUNK_META_LIST, protoChunk.chunkMetaList);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunkAccess
+     */
+    public static void loadChunkMetaNbt(NBTTagCompound cmp, IChunkAccess chunkAccess) {
+        Chunk chunk = null;
+        if (chunkAccess instanceof Chunk) {
+            chunk = (Chunk) chunkAccess;
+        } else if (chunkAccess instanceof PlayerChunk) {
+            chunk = ((PlayerChunk) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunkExtension) {
+            chunk = ((ProtoChunkExtension) chunkAccess).getChunk();
+        } else if (chunkAccess instanceof ProtoChunk) {
+            storeChunkMetaNbt(cmp, (ProtoChunk) chunkAccess);
+            return;
+        }
+        if (chunk == null) throw new IllegalArgumentException("Failed to get chunk to load meta for");
+        loadChunkMetaNbt(cmp, chunk);
+    }
+
+    /**
+     * Save the chunk Meta Data to be loaded later
+     * @param cmp
+     * @param protoChunk
+     */
+    static void storeChunkMetaNbt(NBTTagCompound cmp, ProtoChunk protoChunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            protoChunk.chunkMeta = cmp.getCompound(CHUNK_META);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            protoChunk.chunkMetaList = cmp.getList(CHUNK_META_LIST, 10);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from NBT
+     * @param cmp
+     * @param chunk
+     */
+    static void loadChunkMetaNbt(NBTTagCompound cmp, Chunk chunk) {
+        if (cmp.hasKey(CHUNK_META)) {
+            loadChunkMeta(cmp.getCompound(CHUNK_META), chunk);
+        } else if (cmp.hasKey(CHUNK_META_LIST)) {
+            loadChunkMetaList(cmp.getList(CHUNK_META_LIST, 10), chunk);
+        }
+    }
+
+    /**
+     * Loads this chunks Meta Data from a ProtoChunk
+     * @param protoChunk
+     * @param chunk
+     */
+    public static void loadChunkMetaNbt(ProtoChunk protoChunk, Chunk chunk) {
+        if (protoChunk.chunkMeta != null) {
+            loadChunkMeta(protoChunk.chunkMeta, chunk);
+        } else if (protoChunk.chunkMetaList != null) {
+            loadChunkMetaList(protoChunk.chunkMetaList, chunk);
+        }
+    }
+
+    private static void loadChunkMeta(NBTTagCompound chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        for (String key : chunkMeta.getKeys()) {
+            NBTTagCompound e = chunkMeta.getCompound(key);
+            meta = loadBlockMeta(meta, deserializeOldLoc(key), e);
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static void loadChunkMetaList(NBTTagList chunkMeta, Chunk chunk) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        final int size = chunkMeta.size();
+        for (int i = 0; i < size; i++) {
+            NBTTagCompound e = chunkMeta.getCompound(i);
+            if (e.hasKey(BLOCK_POS)) {
+                NBTTagCompound blockPos = e.getCompound(BLOCK_POS);
+                meta = loadBlockMeta(meta, getBlockPosFromCompound(blockPos), e);
+            }
+        }
+        chunk.chunkMeta = meta;
+    }
+
+    private static ChunkPersistentMeta loadBlockMeta(ChunkPersistentMeta meta, Vector3i key, NBTTagCompound e) {
+        PersistentMetaMap map = getMetaMapFromCompound(e);
+        if (map != null && !map.isEmpty()) {
+            if (meta == null) {
+                meta = new ChunkPersistentMeta();
+            }
+            meta.put(key, map);
+        }
+        return meta;
+    }
+
+    private static Vector3i getBlockPosFromCompound(NBTTagCompound pos) {
+        return new Vector3i(pos.getInt("x"), pos.getInt("y"), pos.getInt("z"));
+    }
+
+    /**
+     * Converts an Object into NBT
+     * @param value
+     * @return
+     */
+    private static NBTBase getNbtFromObject(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof String) {
+            return NBTTagString.a((String) value);
+        } else if (value instanceof ItemStack || value instanceof org.bukkit.inventory.ItemStack) {
+            ItemStack item;
+            if (value instanceof org.bukkit.inventory.ItemStack) {
+                item = CraftItemStack.asNMSCopy((org.bukkit.inventory.ItemStack) value);
+            } else {
+                item = (ItemStack) value;
+            }
+            if (item == null) {
+                return null;
+            }
+            NBTTagCompound itemnbt = new NBTTagCompound();
+            itemnbt.setString(META_TYPE, ITEM);
+            itemnbt.setInt("DataVersion", DataConverters.DATA_VERSION);
+            return item.save(itemnbt);
+        } else if (value instanceof Long) {
+            return NBTTagLong.a((Long) value);
+        } else if (value instanceof Integer) {
+            return NBTTagInt.a((Integer) value);
+        } else if (value instanceof Double) {
+            return NBTTagDouble.a((Double) value);
+        } else if (value instanceof Float) {
+            return NBTTagFloat.a((Float) value);
+        } else if (value instanceof PersistentMetaMap) {
+            return getCompoundFromMetaMap((PersistentMetaMap) value);
+        } else if (value instanceof PersistentMetaList) {
+            NBTTagList list = new NBTTagList();
+            for (Object obj : (Iterable<?>) value) {
+                NBTBase add = getNbtFromObject(obj);
+                if (add != null) {
+                    list.add(add);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        }
+
+        return null;
+    }
+
+    /**
+     * Converts NBT into an Object
+     * @param nbt
+     * @return
+     */
+    @SuppressWarnings("RedundantCast")
+    private static Object getObjectFromNbt(NBTBase nbt) {
+        if (nbt == null) {
+            return null;
+        }
+        if (nbt instanceof NBTTagString) {
+            return (String) nbt.asString();
+            // Redundant casts added to each number so that it will fail to compile
+            // If the method names change for each type. Do not remove.
+        } else if (nbt instanceof NBTTagInt) {
+            return (Integer) ((NBTNumber) nbt).asInt();
+        } else if (nbt instanceof NBTTagLong) {
+            return (Long) ((NBTNumber) nbt).asLong();
+        } else if (nbt instanceof NBTTagFloat) {
+            return (Float) ((NBTNumber) nbt).asFloat();
+        } else if (nbt instanceof NBTTagDouble) {
+            return (Double) ((NBTNumber) nbt).asDouble();
+        } else if (nbt instanceof NBTTagList) {
+            NBTTagList nbtlist = (NBTTagList) nbt;
+            if (nbtlist.isEmpty()) {
+                return null;
+            }
+            PersistentMetaList<Object> list = new PersistentMetaList<>();
+            for (int i = 0; i < nbtlist.size(); i++) {
+                final Object obj = getObjectFromNbt(nbtlist.get(i));
+                if (obj != null) {
+                    list.add(obj);
+                }
+            }
+            return list.isEmpty() ? null : list;
+        } else if (nbt instanceof NBTTagCompound) {
+            NBTTagCompound cmp = (NBTTagCompound) nbt.clone();
+            if (cmp.hasKey(META_TYPE)) {
+                String type = cmp.getString(META_TYPE);
+                cmp.remove(META_TYPE);
+                if (ITEM.equals(type)) {
+                    int version = cmp.hasKey("DataVersion") ? cmp.getInt("DataVersion") : -1;
+                    cmp = DataConverters.convert(DataConverterTypes.ITEM_STACK, cmp, version);
+                    return CraftItemStack.asCraftMirror(ItemStack.a(cmp));
+                } else if (META_MAP.equals(type)) {
+                    final PersistentMetaMap metaMap = getMetaMapFromCompound(cmp);
+                    if (metaMap == null || metaMap.isEmpty()) {
+                        return null;
+                    }
+                    return metaMap;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Converts a NBTTagCompound to a MetaMap
+     * @param cmp
+     * @return
+     */
+    private static PersistentMetaMap getMetaMapFromCompound(NBTTagCompound cmp) {
+        if (cmp.map.isEmpty()) {
+            return null;
+        }
+        PersistentMetaMap map = new PersistentMetaMap();
+        for (Map.Entry<String, NBTBase> entry : cmp.map.entrySet()) {
+            final Object metaData = getObjectFromNbt(entry.getValue());
+            if (metaData != null) {
+                map.put(entry.getKey(), metaData);
+            }
+        }
+        return map;
+    }
+
+    /**
+     * Converts a MetaMap into an NBTTagCompount
+     * @param map
+     * @return
+     */
+    private static NBTTagCompound getCompoundFromMetaMap(PersistentMetaMap map) {
+        NBTTagCompound cmp = new NBTTagCompound();
+        if (map.isEmpty()) {
+            return cmp;
+        }
+        cmp.setString(META_TYPE, META_MAP);
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            NBTBase add = getNbtFromObject(entry.getValue());
+            if (add != null) {
+                cmp.set(entry.getKey(), add);
+            }
+        }
+        return cmp;
+    }
+
+    /**
+     * Translates BlockPos to a String form
+     * @param coords
+     * @return
+     */
+    private static NBTTagCompound serializePos(Vector3i coords) {
+        if (coords == null) {
+            return null;
+        }
+        NBTTagCompound cmp = new NBTTagCompound();
+        cmp.setInt("x", coords.x);
+        cmp.setInt("y", coords.y);
+        cmp.setInt("z", coords.z);
+        return cmp;
+    }
+
+    private static final Pattern COLON_SPLIT = Pattern.compile(":");
+    /**
+     * Parses a string into BlockPos
+     *
+     * @param loc
+     * @return
+     */
+    private static Vector3i deserializeOldLoc(String loc) {
+        if (loc != null)  {
+            String[] args = COLON_SPLIT.split(loc, 3);
+            if (args.length == 3) {
+                try {
+                    int x = (int) Math.floor(Float.parseFloat(args[0]));
+                    int y = (int) Math.floor(Float.parseFloat(args[1]));
+                    int z = (int) Math.floor(Float.parseFloat(args[2]));
+                    return new Vector3i(x, y, z);
+                } catch (NumberFormatException ignored) {}
+            }
+        }
+        return null;
+    }
+
+    public static void processSetAir(Chunk chunk, BlockPosition pos) {
+        ChunkPersistentMeta meta = chunk.chunkMeta;
+        if (meta == null) {
+            return;
+        }
+        Vector3i coords = new Vector3i(pos.getX(), pos.getY(), pos.getZ());
+        if (meta.containsKey(coords)) {
+            new BlockWithPersistentMetaClearedEvent(MCUtil.toLocation(chunk.world, pos).getBlock()).callEvent();
+        }
+    }
+
+    public static void filterTileEntityMeta(NBTTagCompound cmp) {
+        cmp.remove(TILEENTITY_META);
+    }
+
+    public static void reload() {
+        // Players are not guaranteed to be in a chunk if dead
+        for (Player player: Bukkit.getOnlinePlayers()) {
+            player.getTempMeta().clear();
+        }
+        for (WorldServer world : MinecraftServer.getServer().getWorlds()) {
+            for (Entity entity : world.entitiesById.values()) {
+                entity.getBukkitEntity().getTempMeta().clear();
+            }
+            for (PlayerChunk playerChunk : world.getChunkProvider().playerChunkMap.visibleChunks.values()) {
+                Chunk chunk = playerChunk.getChunk();
+                if (chunk == null) continue;
+                chunk.chunkTempMeta.clear();
+            }
+        }
+    }
+
+    public static Map<String, Object> getChunkTempMeta(Block block, boolean isWrite) {
+        Location loc = block.getLocation();
+        Chunk chunk = ((CraftChunk) block.getChunk()).getHandle();
+        Vector3i pos = new Vector3i(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+        Map<String, Object> map = chunk.chunkTempMeta.get(pos);
+        if (map == null) {
+            if (!isWrite) {
+                return null;
+            }
+            map = new HashMap<>(0);
+            chunk.chunkTempMeta.put(pos, map);
+        }
+        return map;
+    }
+
+    public static class ChunkTempMeta extends HashMap<Vector3i, Map<String, Object>> {
+        public ChunkTempMeta() {
+            super(0);
+        }
+
+        public ChunkTempMeta(Map<? extends Vector3i, ? extends Map<String, Object>> m) {
+            super(m);
+        }
+
+        public ChunkTempMeta clone() {
+            return (ChunkTempMeta) new ChunkTempMeta(this);
+        }
+    }
+
+    public static class ChunkPersistentMeta extends HashMap<Vector3i, PersistentMetaMap> {
+        ChunkPersistentMeta() {
+            super(0);
+        }
+
+        ChunkPersistentMeta(Map<? extends Vector3i, ? extends PersistentMetaMap> m) {
+            super(m);
+        }
+
+        public ChunkPersistentMeta clone() {
+            return new ChunkPersistentMeta(this);
+        }
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index 300884804b..22ad912346 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -1339,6 +1339,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     chunk = ((ProtoChunkExtension) ichunkaccess).u();
                 } else {
                     chunk = new Chunk(this.world, (ProtoChunk) ichunkaccess);
+                    net.minecraft.server.MetaApiAccessor.loadChunkMetaNbt((ProtoChunk) ichunkaccess, chunk); // PaperDragon
                     playerchunk.a(new ProtoChunkExtension(chunk));
                 }
 
diff --git a/src/main/java/net/minecraft/server/level/WorldServer.java b/src/main/java/net/minecraft/server/level/WorldServer.java
index 7e032845fe..c05a7e0cd2 100644
--- a/src/main/java/net/minecraft/server/level/WorldServer.java
+++ b/src/main/java/net/minecraft/server/level/WorldServer.java
@@ -174,7 +174,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     public static final BlockPosition a = new BlockPosition(100, 50, 0);
     private static final Logger LOGGER = LogManager.getLogger();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    public final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap(); // PaperDragon - private -> public
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
     public final ChunkProviderServer chunkProvider; // Paper - public
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 429f0591c6..0b60b70210 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -145,6 +145,7 @@ import org.bukkit.plugin.PluginManager;
 public abstract class Entity implements INamableTileEntity, ICommandListener, net.minecraft.server.KeyedObject { // Paper
 
     // CraftBukkit start
+    public com.domnian.paperdragon.api.meta.PersistentMetaMap metaMap = null; // PaperDragon
     private static final int CURRENT_LEVEL = 2;
     boolean preserveMotion = true; // Paper - keep initial motion on first setPositionRotation
     static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
@@ -1633,6 +1634,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
                 this.yaw = 0;
             }
 
+            net.minecraft.server.MetaApiAccessor.saveEntityMeta(this, nbttagcompound); // PaperDragon
             if (Float.isNaN(this.pitch)) {
                 this.pitch = 0;
             }
@@ -1861,6 +1863,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
             // CraftBukkit end
 
             // Paper start - Restore the entity's origin location
+            net.minecraft.server.MetaApiAccessor.loadEntityMeta(this, nbttagcompound); // PaperDragon
             NBTTagList originTag = nbttagcompound.getList("Paper.Origin", 6);
             if (!originTag.isEmpty()) {
                 origin = new org.bukkit.Location(world.getWorld(), originTag.getDoubleAt(0), originTag.getDoubleAt(1), originTag.getDoubleAt(2));
diff --git a/src/main/java/net/minecraft/world/level/World.java b/src/main/java/net/minecraft/world/level/World.java
index 2fc9bdcc54..eaa7d63d9e 100644
--- a/src/main/java/net/minecraft/world/level/World.java
+++ b/src/main/java/net/minecraft/world/level/World.java
@@ -186,7 +186,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.WorldDataServer) worlddatamutable).getName()); // Spigot
         this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(((net.minecraft.world.level.storage.WorldDataServer) worlddatamutable).getName(), this.spigotConfig); // Paper
         this.chunkPacketBlockController = this.paperConfig.antiXray ? new ChunkPacketBlockControllerAntiXray(this, executor) : ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
-        this.dragonConfig = new com.domnian.paperdragon.DragonWorldConfig(((WorldDataServer)worlddatamutable).getName(), this.spigotConfig, this.paperConfig); // PaperDragon
+        this.dragonConfig = new com.domnian.paperdragon.DragonWorldConfig(((net.minecraft.world.level.storage.WorldDataServer)worlddatamutable).getName(), this.spigotConfig, this.paperConfig); // PaperDragon
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
@@ -502,6 +502,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                     this.a(blockposition, iblockdata1, iblockdata2);
                 }
                 */
+                if (block == Blocks.AIR) net.minecraft.server.MetaApiAccessor.processSetAir(chunk, blockposition); // PaperDragon
 
                 // CraftBukkit start
                 if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java b/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
index 93d02ccb87..1a1d7e2354 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/TileEntity.java
@@ -96,6 +96,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
     }
 
     public void load(IBlockData iblockdata, NBTTagCompound nbttagcompound) {
+        net.minecraft.server.MetaApiAccessor.loadTileEntityMeta(this, nbttagcompound); // PaperDragon
         this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
         // CraftBukkit start - read container
         this.persistentDataContainer.clear(); // Paper - clear instead of reinit
@@ -118,6 +119,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
             throw new RuntimeException(this.getClass() + " is missing a mapping! This is a bug!");
         } else {
             nbttagcompound.setString("id", minecraftkey.toString());
+            net.minecraft.server.MetaApiAccessor.saveTileEntityMeta(this, nbttagcompound); // PaperDragon
             nbttagcompound.setInt("x", this.position.getX());
             nbttagcompound.setInt("y", this.position.getY());
             nbttagcompound.setInt("z", this.position.getZ());
@@ -254,6 +256,7 @@ public abstract class TileEntity implements net.minecraft.server.KeyedObject { /
         }
     }
 
+    public com.domnian.paperdragon.api.meta.PersistentMetaMap metaMap; // PaperDragon
     // CraftBukkit start - add method
     // Paper start
     public InventoryHolder getOwner() {
diff --git a/src/main/java/net/minecraft/world/level/chunk/Chunk.java b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
index 0727b12b5f..4bfcc95795 100644
--- a/src/main/java/net/minecraft/world/level/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
@@ -187,6 +187,8 @@ public class Chunk implements IChunkAccess {
         return bukkitChunk;
     }
 
+    public net.minecraft.server.MetaApiAccessor.ChunkPersistentMeta chunkMeta; // PaperDragon
+    public net.minecraft.server.MetaApiAccessor.ChunkTempMeta chunkTempMeta = new net.minecraft.server.MetaApiAccessor.ChunkTempMeta(); // PaperDragon
     public boolean mustNotSave;
     public boolean needsDecoration;
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 7bfac4e852..ccaa5a9410 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -65,6 +65,8 @@ public class ProtoChunk implements IChunkAccess {
     private final Map<WorldGenStage.Features, BitSet> t;
     private volatile boolean u;
     final World world; // Paper - Anti-Xray - Add world // Paper - private -> default
+    public NBTTagCompound chunkMeta; // PaperDragon
+    public net.minecraft.nbt.NBTTagList chunkMetaList; // PaperDragon
 
     // Paper start - Anti-Xray - Add world
     @Deprecated public ProtoChunk(ChunkCoordIntPair chunkcoordintpair, ChunkConverter chunkconverter) { this(chunkcoordintpair, chunkconverter, null); } // Notice for updates: Please make sure this constructor isn't used anywhere
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
index 7a82d43d51..d7518016c3 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunkExtension.java
@@ -208,6 +208,7 @@ public class ProtoChunkExtension extends ProtoChunk {
         throw (UnsupportedOperationException) SystemUtils.c((Throwable) (new UnsupportedOperationException("Meaningless in this context")));
     }
 
+    public Chunk getChunk() { return this.u(); } // PaperDragon - OBFHELPER
     public Chunk u() {
         return this.a;
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
index 4eaf497d04..55c5f6d6ba 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkRegionLoader.java
@@ -258,6 +258,7 @@ public class ChunkRegionLoader {
         }
 
         HeightMap.a((IChunkAccess) object, enumset);
+        net.minecraft.server.MetaApiAccessor.loadChunkMetaNbt(nbttagcompound1, (IChunkAccess) object); // PaperDragon
         NBTTagCompound nbttagcompound4 = nbttagcompound1.getCompound("Structures");
 
         ((IChunkAccess) object).a(a(definedstructuremanager, nbttagcompound4, worldserver.getSeed()));
@@ -448,6 +449,7 @@ public class ChunkRegionLoader {
         nbttagcompound.set("Level", nbttagcompound1);
         nbttagcompound1.setInt("xPos", chunkcoordintpair.x);
         nbttagcompound1.setInt("zPos", chunkcoordintpair.z);
+        net.minecraft.server.MetaApiAccessor.saveChunkMetaNbt(nbttagcompound1, ichunkaccess); // PaperDragon
         nbttagcompound1.setLong("LastUpdate", asyncsavedata != null ? asyncsavedata.worldTime : worldserver.getTime()); // Paper - async chunk unloading
         nbttagcompound1.setLong("InhabitedTime", ichunkaccess.getInhabitedTime());
         nbttagcompound1.setString("Status", ichunkaccess.getChunkStatus().d());
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java b/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
index 202d0aea44..cea69e4693 100644
--- a/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
+++ b/src/main/java/net/minecraft/world/level/storage/WorldDataServer.java
@@ -85,6 +85,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
     private boolean D;
     private final CustomFunctionCallbackTimerQueue<MinecraftServer> E;
     public WorldServer world; // CraftBukkit
+    public com.domnian.paperdragon.api.meta.PersistentMetaMap metaMap = new com.domnian.paperdragon.api.meta.PersistentMetaMap(); // PaperDragon
 
     private WorldDataServer(@Nullable DataFixer datafixer, int i, @Nullable NBTTagCompound nbttagcompound, boolean flag, int j, int k, int l, float f, long i1, long j1, int k1, int l1, int i2, boolean flag1, int j2, boolean flag2, boolean flag3, boolean flag4, WorldBorder.c worldborder_c, int k2, int l2, @Nullable UUID uuid, LinkedHashSet<String> linkedhashset, CustomFunctionCallbackTimerQueue<MinecraftServer> customfunctioncallbacktimerqueue, @Nullable NBTTagCompound nbttagcompound1, NBTTagCompound nbttagcompound2, WorldSettings worldsettings, GeneratorSettings generatorsettings, Lifecycle lifecycle) {
         this.k = datafixer;
@@ -129,9 +130,13 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
         });
 
         // CraftBukkit - decompile error
-        return new WorldDataServer(datafixer, i, nbttagcompound, dynamic.get("WasModded").asBoolean(false), dynamic.get("SpawnX").asInt(0), dynamic.get("SpawnY").asInt(0), dynamic.get("SpawnZ").asInt(0), dynamic.get("SpawnAngle").asFloat(0.0F), j, dynamic.get("DayTime").asLong(j), levelversion.a(), dynamic.get("clearWeatherTime").asInt(0), dynamic.get("rainTime").asInt(0), dynamic.get("raining").asBoolean(false), dynamic.get("thunderTime").asInt(0), dynamic.get("thundering").asBoolean(false), dynamic.get("initialized").asBoolean(true), dynamic.get("DifficultyLocked").asBoolean(false), WorldBorder.c.a(dynamic, WorldBorder.c), dynamic.get("WanderingTraderSpawnDelay").asInt(0), dynamic.get("WanderingTraderSpawnChance").asInt(0), (UUID) dynamic.get("WanderingTraderId").read(MinecraftSerializableUUID.a).result().orElse(null), (LinkedHashSet) dynamic.get("ServerBrands").asStream().flatMap((dynamic1) -> {
+        // PaperDragon start
+        WorldDataServer worldData = new WorldDataServer(datafixer, i, nbttagcompound, dynamic.get("WasModded").asBoolean(false), dynamic.get("SpawnX").asInt(0), dynamic.get("SpawnY").asInt(0), dynamic.get("SpawnZ").asInt(0), dynamic.get("SpawnAngle").asFloat(0.0F), j, dynamic.get("DayTime").asLong(j), levelversion.a(), dynamic.get("clearWeatherTime").asInt(0), dynamic.get("rainTime").asInt(0), dynamic.get("raining").asBoolean(false), dynamic.get("thunderTime").asInt(0), dynamic.get("thundering").asBoolean(false), dynamic.get("initialized").asBoolean(true), dynamic.get("DifficultyLocked").asBoolean(false), WorldBorder.c.a(dynamic, WorldBorder.c), dynamic.get("WanderingTraderSpawnDelay").asInt(0), dynamic.get("WanderingTraderSpawnChance").asInt(0), (UUID) dynamic.get("WanderingTraderId").read(MinecraftSerializableUUID.a).result().orElse(null), (LinkedHashSet) dynamic.get("ServerBrands").asStream().flatMap((dynamic1) -> {
             return SystemUtils.a(dynamic1.asString().result());
         }).collect(Collectors.toCollection(Sets::newLinkedHashSet)), new CustomFunctionCallbackTimerQueue<>(CustomFunctionCallbackTimers.a, dynamic.get("ScheduledEvents").asStream()), (NBTTagCompound) dynamic.get("CustomBossEvents").orElseEmptyMap().getValue(), nbttagcompound1, worldsettings, generatorsettings, lifecycle);
+        net.minecraft.server.MetaApiAccessor.loadWorldMeta(worldData, dynamic);
+        return worldData;
+        // PaperDragon end
     }
 
     @Override
@@ -208,7 +213,7 @@ public class WorldDataServer implements IWorldDataServer, SaveData {
         if (this.B != null) {
             nbttagcompound.a("WanderingTraderId", this.B);
         }
-
+        net.minecraft.server.MetaApiAccessor.saveWorldMeta(this, nbttagcompound); // PaperDragon
         nbttagcompound.setString("Bukkit.Version", Bukkit.getName() + "/" + Bukkit.getVersion() + "/" + Bukkit.getBukkitVersion()); // CraftBukkit
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 98ab124b4d..9d3e981b1c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -41,6 +41,8 @@ import org.bukkit.plugin.Plugin;
 
 public class CraftChunk implements Chunk {
     private WeakReference<net.minecraft.world.level.chunk.Chunk> weakChunk;
+    private final com.domnian.paperdragon.api.meta.TempMetaMap tempMeta = new com.domnian.paperdragon.api.meta.TempMetaMap(); // PaperDragon
+    public com.domnian.paperdragon.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // PaperDragon
     private final WorldServer worldServer;
     private final int x;
     private final int z;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 865ae39938..1a49e4fc17 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -949,6 +949,9 @@ public final class CraftServer implements Server {
             ));
             if (console.isDebugging()) TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper
         }
+        // PaperDragon start
+        net.minecraft.server.MetaApiAccessor.reload();
+        // PaperDragon end
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
         enablePlugins(PluginLoadOrder.POSTWORLD);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index a4bd0d352c..97b52174df 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -156,4 +156,11 @@ public class CraftBlockEntityState<T extends TileEntity> extends CraftBlockState
     public PersistentDataContainer getPersistentDataContainer() {
         return this.getSnapshot().persistentDataContainer;
     }
+
+    // PaperDragon start
+    @Override
+    public boolean isTileEntity() {
+        return tileEntity != null;
+    }
+    // PaperDragon end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 1960f01b5e..5b84b47998 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -290,4 +290,11 @@ public class CraftBlockState implements BlockState {
             throw new IllegalStateException("The blockState must be placed to call this method");
         }
     }
+
+    // PaperDragon start
+    @Override
+    public boolean isTileEntity() {
+        return false;
+    }
+    // PaperDragon end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 295ffab086..95d008fa11 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -178,6 +178,8 @@ import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
+    private final com.domnian.paperdragon.api.meta.TempMetaMap tempMeta = new com.domnian.paperdragon.api.meta.TempMetaMap(); // PaperDragon
+    public com.domnian.paperdragon.api.meta.TempMetaMap getTempMeta() { return tempMeta; } // PaperDragon
     private static PermissibleBase perm;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index b14cec316b..4703c067ce 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -1466,6 +1466,11 @@ public class CraftEventFactory {
         InventoryCloseEvent event = new InventoryCloseEvent(human.activeContainer.getBukkitView(), reason); // Paper
         human.world.getServer().getPluginManager().callEvent(event);
         human.activeContainer.transferTo(human.defaultContainer, human.getBukkitEntity());
+        // PaperDragon start
+        if (event.getInventory().getViewers().isEmpty()) {
+            org.bukkit.craftbukkit.inventory.CraftInventory.meta.remove(((org.bukkit.craftbukkit.inventory.CraftInventory)event.getInventory()).getInventory());
+        }
+        // PaperDragon end
     }
 
     public static ItemStack handleEditBookEvent(EntityPlayer player, int itemInHandIndex, ItemStack itemInHand, ItemStack newBookItem) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index c3fa97ac34..c582e879ae 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -32,6 +32,17 @@ import org.bukkit.inventory.ItemStack;
 public class CraftInventory implements Inventory {
     protected final IInventory inventory;
 
+    // PaperDragon start
+    public static final java.util.WeakHashMap<IInventory, HashMap<String, Object>> meta = new java.util.WeakHashMap<IInventory, HashMap<String, Object>>(64);
+    public HashMap<String, Object> getMeta() {
+        HashMap<String, Object> metaMap = meta.get(inventory);
+        if (metaMap == null) {
+            metaMap = new HashMap<String, Object>();
+            meta.put(inventory, metaMap);
+        }
+        return metaMap;
+    } // PaperDragon end
+
     public CraftInventory(IInventory inventory) {
         this.inventory = inventory;
     }
-- 
2.20.1.windows.1

